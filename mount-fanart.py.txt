#!/opt/mount-api/venv/bin/python
# -*- coding: utf-8 -*-
import requests
import os
import io
import tempfile
import time
import json
from mutagen import File
from mpd import MPDClient
from PIL import Image, ImageFont, ImageDraw
from urllib.parse import urlparse, urlunparse, quote_plus
import threading

# Configuration ecran framebuffer (resolution, profondeur) evite trop 720p
os.system("sudo fbset -xres 1920 -yres 1080 -vxres 1920 -vyres 1080 -depth 32")

# Configuration MPD (host, port)
MPD_HOST = "localhost"
MPD_PORT = 6600

# Ecran framebuffer a utiliser (tty1 par exemple)
SCREEN = "/dev/tty1"

# Chemins vers logos et images
LOGO_PATH = "/diesis/logo/logo_diesis_1280.jpg"
BLACK_SCREEN_PATH = "/diesis/logo/black.jpg"

# Repertoire local pour cache des fanarts artistes
FANART_CACHE_DIR = "/mnt/HDD/fanart/"
os.makedirs(FANART_CACHE_DIR, exist_ok=True)

# Delai avant ecran noir (screensaver) en secondes
SCREENSAVER_DELAY = 30

# Temps pendant lequel la pochette reste affichee apres stop/pause
COVER_HOLD_TIME = 10

# Cle API theAudioDB 1sec max requette laurent94jbl1 via Laurent94jbl@diesis
THEAUDIODB_API_KEY = "18626d636d76696473706d"

# Cle API Fanart.tv (diesis-fidelity key fanart tv)
FANART_API_KEY = "3fb16353330878ca22467a20612512f5"

# Fonction de log avec horodatage ---
def log(msg):
    timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
    print(f"[mount-fanart] {timestamp} {msg}")

# Creer une image noire si elle n'existe pas (ecran noir)
def create_black_image_if_missing():
    if not os.path.exists(BLACK_SCREEN_PATH):
        log(f"Creating black screen at {BLACK_SCREEN_PATH}")
        img = Image.new('RGB', (1280, 720), (0, 0, 0))
        img.save(BLACK_SCREEN_PATH, "JPEG")

# Afficher le logo sur l'ecran via fbi ---
def show_logo():
    if not os.path.exists(LOGO_PATH):
        log(f"Logo not found: {LOGO_PATH}")
        return
    os.system("killall -q fbi")  # Arrete toute instance fbi existante
    os.system(f"fbi -T 1 -a --noverbose -t 0 {LOGO_PATH} < {SCREEN} > {SCREEN} 2>&1")
    log("Logo displayed")

# Afficher l'ecran noir via fbi
def show_black_screen():
    if not os.path.exists(BLACK_SCREEN_PATH):
        create_black_image_if_missing()
    os.system("killall -q fbi")
    os.system(f"fbi -T 1 -a --noverbose -t 0 {BLACK_SCREEN_PATH} < {SCREEN} > {SCREEN} 2>&1")
    log("Black screen displayed")

# Connexion au serveur MPD
def connect_mpd():
    log("Connecting to MPD...")
    client = MPDClient()
    client.timeout = 20
    client.idletimeout = None
    try:
        client.connect(MPD_HOST, MPD_PORT)
    except Exception as e:
        log(f"Failed to connect to MPD: {e}")
        raise
    log("Connected to MPD")
    return client

# Recup info audio (PCM, DSD...) a partir du status MPD
def connect_mpd():
    client = MPDClient()
    client.timeout = 20
    client.idletimeout = None
    client.connect(MPD_HOST, MPD_PORT)
    return client

def connect_mpd_retry():
    while True:
        try:
            return connect_mpd()
        except Exception as e:
            log(f"MPD pas dispo, retry dans 3s... ({e})")
            time.sleep(3)

def get_audio_format(client):
    status = client.status()
    audio_info = status.get("audio", "").lower()
    log(f"[DEBUG] MPD audio = {audio_info}")

    dsd_freqs = {"64": 2822.4, "128": 5644.8, "256": 11289.6, "512": 22579.2}

    try:
        if audio_info.startswith("dsd") and ":" in audio_info:
            rate, channels = audio_info.split(":")
            rate = rate.replace("dsd", "")
            rate_khz = dsd_freqs.get(rate)
            return f"DSD : {rate} ({rate_khz:.1f} kHz)" if rate_khz else f"DSD{rate} {'Stereo' if channels=='2' else channels+' ch'}"
        if audio_info and ":" in audio_info:
            sample_rate, bits, channels = map(int, audio_info.split(":"))
            return f"PCM {bits} bit / {int(sample_rate/1000)} kHz {'Stereo' if channels==2 else str(channels)+' ch'}"
    except:
        pass
    return "N/A"

# Chercher une pochette locale classique dans un dossier + cache fanart ---
def find_local_cover(folder, artist_name=None):
    # 1. Chercher dans le dossier de la musique
    for name in ["cover.jpg", "cover.png", "folder.jpg", "folder.png", "front.jpg", "front.png"]:
        path = os.path.join(folder, name)
        if os.path.exists(path):
            return path

    # Chercher dans le cache fanart si artist_name est fourni
    if artist_name:
        artist_key = artist_name.lower().replace(" ", "_").replace("/", "_").replace(";", "_")
        cache_path = os.path.join(FANART_CACHE_DIR, f"{artist_key}.jpg")
        if os.path.exists(cache_path):
            log(f"Using cached fanart from {cache_path}")
            return cache_path

    # Rien trouve
    return None

# Extraire une pochette embarquee dans un fichier audio (format MP3, FLAC...) ---
def extract_embedded_cover(file_path):
    try:
        audio = File(file_path)
        if audio is None:
            return None
        if hasattr(audio, 'pictures') and audio.pictures:
            return io.BytesIO(audio.pictures[0].data)
        if audio.tags:
            for tag in audio.tags.values():
                if hasattr(tag, 'data'):
                    return io.BytesIO(tag.data)
    except Exception as e:
        log(f"Error extracting embedded cover: {e}")
    return None

# Telecharger pochette de flux streaming a partir des tags MPD ---
def download_stream_cover(tags):
    log("Searching for stream cover in tags...")
    for key in ['track', 'AlbumArtist', 'albumarturi', 'AlbumArtURI', 'albumArtURI', 'comment']:
        value = tags.get(key)
        if value and "http" in value:
            url = value.split(';')[-1] if ';' in value else value
            try:
                response = requests.get(url, timeout=10)
                response.raise_for_status()
                log(f"Stream cover downloaded from {url}")
                return io.BytesIO(response.content)
            except Exception as e:
                log(f"Failed to download stream cover from {url}: {e}")
                pass
    return None

# Essayer de recuperer la pochette d'un stream Qobuz via URL track ---
def try_fetch_mconnect_qobuz_stream_cover(track_url):
    if not track_url:
        return None
    parsed = urlparse(track_url)
    if not parsed.path.endswith(".flac"):
        return None
    path_parts = parsed.path.rsplit('/', 1)
    if len(path_parts) != 2:
        return None
    base_path, filename = path_parts
    track_id = filename.replace(".flac", "")
    new_path = f"{base_path}/images/{track_id}.jpg"
    new_url = urlunparse((parsed.scheme, parsed.netloc, new_path, '', '', ''))
    try:
        resp = requests.get(new_url, timeout=5)
        if resp.status_code == 200:
            return io.BytesIO(resp.content)
    except Exception as e:
        log(f"Failed to fetch Qobuz stream cover: {e}")
    return None

import xml.etree.ElementTree as ET

def try_fetch_bubble_stream_cover(track_metadata_xml):
    if not track_metadata_xml:
        return None
    try:
        ns = {
            'upnp': 'urn:schemas-upnp-org:metadata-1-0/upnp/',
            'dc': 'http://purl.org/dc/elements/1.1/',
        }
        root = ET.fromstring(track_metadata_xml)
        album_art = root.find('.//upnp:albumArtURI', ns)
        if album_art is not None and album_art.text:
            resp = requests.get(album_art.text, timeout=10)
            if resp.status_code == 200:
                return io.BytesIO(resp.content)
    except Exception as e:
        print(f"[bubble] Error fetching cover: {e}")
    return None


import json
import os

MOUNT_FILE = "/opt/mount-api/mount-diesis-api.json"

def clear_composer_file():
    """Vide le fichier cache du compositeur."""
    try:
        # Si le fichier existe, on le vide
        with open(MOUNT_FILE, "w", encoding="utf-8") as f:
            json.dump({}, f, ensure_ascii=False)
        print("[composer] Cache vidé")
    except Exception as e:
        print(f"[composer] Erreur purge cache: {e}")


def extract_composer_from_performers(tags):
    """
    Retourne le nom du compositeur à partir des tags MPD
    ou du fichier JSON MOUNT_FILE.
    """
    performers = tags.get('performers') or tags.get('Performers')
    if performers:
        for part in performers.split('-'):
            if "Composer" in part:
                return part.strip().split(',')[0]

    # Sinon, chercher dans le cache JSON
    if os.path.exists(MOUNT_FILE):
        try:
            with open(MOUNT_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)
                composer = data.get('composer')
                if composer:
                    return composer.strip()
        except Exception as e:
            print(f"[extract_composer_from_performers] Erreur lecture {MOUNT_FILE}: {e}")

    return None

# --- separateurs ---

import json
import os
import re

NORMALIZE_FILE = "/opt/mount-api/mount-fanart-name.json"

# --- Logging simple ---
def log(msg):
    print(f"[normalize-def-log] {msg}", flush=True)

# --- Chargement du JSON de normalisation ---
def load_artist_normalize():
    if os.path.exists(NORMALIZE_FILE):
        with open(NORMALIZE_FILE, "r", encoding="utf-8") as f:
            log("Fichier de normalisation chargé")
            return json.load(f)
    log("Fichier de normalisation absent")
    return {}

ARTIST_NORMALIZE = load_artist_normalize()

# --- Normalisation via JSON ---
def normalize_artist_from_json(name):
    if name in ARTIST_NORMALIZE:
        val = ARTIST_NORMALIZE[name]
        if isinstance(val, list):
            log(f'"{name}" -> liste {val}')
            return val
        else:
            log(f'"{name}" -> "{val}"')
            return [val]  # juste mettre la string dans une liste, pas de split
    else:
        log(f'Aucun mapping pour "{name}"')
        return [name]

# --- Split intelligent des artistes ---

def extract_feat_from_title(title):
    # Cherche feat, ft, featuring avec ou sans parenthèses
    match = re.search(r'(?i)(?:\(|\s)?(feat\.?|ft\.?|featuring)\s+([^\)]+)', title)
    if match:
        feats = [a.strip() for a in re.split(r',|&|/', match.group(2))]
        log(f"[extract_feat_from_title] Feats détectés dans '{title}': {feats}")
        return feats
    return []

def get_all_artists(track):
    """Retourne tous les artistes normalisés du track : principal + feats détectés dans le titre."""
    artist_name = track.get('artist', '')
    title = track.get('title', '')

    # Artiste(s) principal(aux)
    main_artists = split_artists_smart(artist_name)

    # Extraction des feats dans le titre
    feat_artists = extract_feat_from_title(title)
    normalized_feat = []
    for a in feat_artists:
        normalized_feat.extend(normalize_artist_from_json(a))

    # Fusionner sans doublons
    seen = set()
    all_artists = []
    for a in main_artists + normalized_feat:
        if a not in seen:
            seen.add(a)
            all_artists.append(a)

    log(f"[get_all_artists] Artistes finaux pour '{title}': {all_artists}")
    return all_artists

def split_artists_smart(artist_name):
    if not artist_name:
        return []

    artist_name = artist_name.strip()

    # --- Vérifier si mapping complet existe dans le JSON ---
    if artist_name in ARTIST_NORMALIZE:
        normalized = normalize_artist_from_json(artist_name)  # retourne déjà une liste
        log(f"[split_artists_smart] Mapping complet trouvé pour '{artist_name}' -> {normalized}")
        return normalized  # ✅ on retourne la liste directement

    # --- Sinon split normal pour autres cas ---
    separators = [
        r',\s+',
        r';',
        r'(?i)[\(]?\s*feat\.?\s+',
        r'(?i)[\(]?\s*ft\.?\s+',
        r'(?i)[\(]?\s*featuring\s+',
    ]

    parts = [artist_name]
    for pat in separators:
        new_list = []
        for art in parts:
            split_parts = re.split(pat, art)
            new_list.extend([a.strip() for a in split_parts if a.strip()])
        parts = new_list

    # --- Appliquer normalisation pour les parties individuelles ---
    seen = set()
    out = []
    for a in parts:
        na_list = normalize_artist_from_json(a)  # toujours une liste
        for na in na_list:
            if na not in seen:
                seen.add(na)
                out.append(na)

    log(f"[split_artists_smart] Résultat final split + normalisation: {out}")
    return out




def get_fanart_candidates(track):
    fanarts = []
    processed_artists = set()
    track_title = track.get('title', '')

    log(f"[mount-fanart-def-candidate] Traitement du track: '{track_title}'")

    # --- Récupère tous les artistes normalisés (principal + feats) ---
    all_artists = get_all_artists(track)
    log(f"[mount-fanart-def-candidate] Artistes normalisés et splittés: {all_artists}")

    for artist in all_artists:
        if artist in processed_artists:
            log(f"[mount-fanart-def-candidate] Artiste déjà traité: '{artist}'")
            continue

        processed_artists.add(artist)
        log(f"[mount-fanart-def-candidate] Recherche fanart pour: '{artist}'")

        part_fanarts = try_tadb(artist)
        if part_fanarts:
            log(f"[mount-fanart-def-candidate] Fanart trouvé pour '{artist}': {len(part_fanarts)} image(s)")
            fanarts.extend(part_fanarts)
        else:
            log(f"[mount-fanart-def-candidate] Aucun fanart pour '{artist}'")

    if not fanarts:
        log(f"[mount-fanart-def-candidate] Aucun fanart trouvé pour le track '{track_title}'")

    return fanarts

def normalize_name_for_tadb(name):
    name = name.replace("’", "'")  # uniformiser apostrophe
    name = re.sub(r"\bDi\b", "di", name)  # forcer "Di" -> "di"
    name = re.sub(r"\s+", " ", name.strip())  # espaces propres
    return name


def get_artist_fanart(artist_name, api_key=THEAUDIODB_API_KEY,
                      depth=0, max_depth=5, immediate=False, seen_artists=None):
    import os, io, time
    import requests
    from urllib.parse import quote_plus
    from PIL import Image

    os.makedirs(FANART_CACHE_DIR, exist_ok=True)
    fanarts = []

    # --- set() global pour éviter les répétitions ---
    if seen_artists is None:
        seen_artists = set()

    # --- normalisation du ou des noms avant toute requête ---
    if isinstance(artist_name, list):
        candidates = [normalize_name_for_tadb(a) for a in artist_name]
    else:
        candidates = [normalize_name_for_tadb(artist_name)]

    for artist in candidates:
        # --- Vérifier si déjà extrait
        if artist in seen_artists:
            log(f"Skipping already processed artist: {artist}")
            continue
        seen_artists.add(artist)

        artist_key_base = artist.replace(" ", "_").replace("/", "_").replace(";", "_")

        urls_to_try = []
        safe_artist = quote_plus(artist)
        url = f"https://www.theaudiodb.com/api/v1/json/{api_key}/search.php?s={safe_artist}"
        headers = {"User-Agent": "Kodi/19.4 (X11; Linux x86_64)"}

        try:
            time.sleep(1)
            resp = requests.get(url, headers=headers, timeout=15)
            log(f"TheAudioDB API response status for {artist}: {resp.status_code}")
            if resp.status_code != 200:
                continue

            data = resp.json()

            # --- Aucun résultat pour l'artiste entier ---
            if not data or "artists" not in data or not data["artists"]:
                log(f"No artist found in TheAudioDB response for {artist}")

                # Split seulement si on n'a rien trouvé avec le nom complet
                if depth < max_depth and any(x in artist for x in [",", "/", ";", "&"]):
                    sub_artists = split_artists_smart(artist)
                    log(f"Splitting artist name into: {sub_artists}")
                    fanarts_sub = get_artist_fanart(
                        sub_artists,
                        api_key=api_key,
                        depth=depth + 1,
                        max_depth=max_depth,
                        immediate=immediate,
                        seen_artists=seen_artists   # On transmet la mémoire
                    )
                    if fanarts_sub:
                        fanarts.extend(fanarts_sub)
                        if immediate:
                            return fanarts
                continue

            # --- Résultat trouvé pour l'artiste complet ---
            artist_data = data["artists"][0]
            urls_to_try.extend([
                artist_data.get("strArtistFanart"),
                artist_data.get("strArtistFanart2"),
                artist_data.get("strArtistFanart3"),
                artist_data.get("strArtistFanart4"),
            ])

            # Télécharger les fanarts disponibles
            for idx, fanart_url in enumerate(filter(None, urls_to_try), start=1):
                artist_key = f"{artist_key_base}_{idx}"
                cache_path = os.path.join(FANART_CACHE_DIR, f"{artist_key}.jpg")

                if os.path.exists(cache_path):
                    log(f"Using cached fanart for {artist} #{idx}: {cache_path}")
                    fanarts.append(cache_path)
                else:
                    log(f"Downloading fanart #{idx} for {artist} from {fanart_url}")
                    fanart_resp = requests.get(fanart_url, stream=True, timeout=15)
                    if fanart_resp.status_code == 200:
                        img_data = fanart_resp.content
                        img = Image.open(io.BytesIO(img_data))
                        img = img.resize((1280, 720), Image.LANCZOS)
                        img.save(cache_path, format='JPEG', quality=95)
                        fanarts.append(cache_path)
                        log(f"Fanart #{idx} saved to {cache_path}")
                    else:
                        log(f"Failed to download fanart #{idx} for {artist}: HTTP {fanart_resp.status_code}")

                # Si un fanart est trouvé et immediate=True, on retourne immédiatement
                if fanarts and immediate:
                    return fanarts

        except Exception as e:
            log(f"Exception while fetching fanart for {artist}: {e}")

    if fanarts:
        return fanarts
    else:
        log("No fanart found for any artist")
        return None

# Variables globales pour gestion de l'affichage en boucle
_last_displayed_song_id = None
_last_fanart_change = 0
_fanart_index = 0

def display_image(image_data, title="", artist="", album="", composer="", pcm_info=None, fanart_paths=None, fanart_index=0, song_id=None):
    global _last_displayed_song_id, _last_fanart_change, _fanart_index

    now = time.time()

    # GESTION DE L'INDEX FANART
    # Nouveau morceau : on remet l'index en param
    if song_id != _last_displayed_song_id:
        _fanart_index = fanart_index
        _last_displayed_song_id = song_id
        _last_fanart_change = now
    else:
        # Meme morceau rotation du fanart toutes les 20s
        if fanart_paths and len(fanart_paths) > 1 and now - _last_fanart_change >= 20:
            _fanart_index = (_fanart_index + 1) % len(fanart_paths)
            _last_fanart_change = now
        else:
            # Meme morceau, rotation pas encore necessaire garder fanart actuel
            print("[display_image] Meme morceau, fanart pas encore change, affichage du fanart actuel")

    # --- CHOIX DU FANART COURANT ---
    if fanart_paths and len(fanart_paths) > 0:
        log(f"[fanart-def-candidate] Fanarts détectés : {len(fanart_paths)}")

        # Ici tous les fanarts sont déjà des artistes
        fanart_paths_rot = fanart_paths
        log(f"[fanart-def-candidate] Fanarts artistes : {len(fanart_paths_rot)}")

        # Choix du fanart courant avec protection division par zéro
        fanart_path = fanart_paths_rot[_fanart_index % len(fanart_paths_rot)]
        log(f"[fanart-def-candidate] Sélection rotation -> {_fanart_index % len(fanart_paths_rot)} : {fanart_path}")

    else:
        fanart_path = None
        log("[fanart-def-candidate] Aucun fanart trouvé → None")

    # CHEMIN POLICE ET DIMENSIONS ECRAN
    font_path = "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf"
    screen_w, screen_h = 1920, 1080  # Resolution de l'ecran

    cover_size = 500
    band_height = 300
    border_px = 4
    left_margin = 30
    right_margin = 40
    padding = 30

    font_title = ImageFont.truetype(font_path, 54)
    font_artist = ImageFont.truetype(font_path, 40)
    font_album = ImageFont.truetype(font_path, 34)
    font_pcm = ImageFont.truetype(font_path, 26)
    font_composer = ImageFont.truetype(font_path, 26)

    # CHARGEMENT POCHETTE
    try:
        print("[display_image] Chargement de la pochette...")
        image = Image.open(image_data).convert("RGBA")
        print("[display_image] Pochette charge avec succes")
    except Exception as e:
        print(f"[display_image] Erreur ouverture pochette : {e}")
        return

    # CHARGEMENT FANART
    if fanart_path and os.path.exists(fanart_path):
        try:
            background_img = Image.open(fanart_path).convert("RGB")
            print("[display_image] Fanart charge avec succes")
        except Exception as e:
            print(f"[display_image] Erreur ouverture fanart : {e}")
            background_img = Image.new('RGB', (screen_w, screen_h), (0, 0, 0))
    else:
        print("[display_image] Pas de fanart, fond noir utilise")
        background_img = Image.new('RGB', (screen_w, screen_h), (0, 0, 0))

    # REDIMENSIONNEMENT FANART avant aff
    bg_ratio = background_img.width / background_img.height
    screen_ratio = screen_w / screen_h
    if bg_ratio > screen_ratio:
        new_height = screen_h
        new_width = int(bg_ratio * new_height)
        background_img = background_img.resize((new_width, new_height), Image.LANCZOS)
        left = (new_width - screen_w) // 2
        background_img = background_img.crop((left, 0, left + screen_w, screen_h))
    else:
        new_width = screen_w
        new_height = int(new_width / bg_ratio)
        background_img = background_img.resize((new_width, new_height), Image.LANCZOS)
        top = (new_height - screen_h) // 2
        background_img = background_img.crop((0, top, screen_w, top + screen_h))

    background_img = background_img.convert("RGBA")
    band_y = screen_h - band_height

    # BANDE TRANSPARENTE
    overlay = Image.new('RGBA', (screen_w, band_height), (0, 0, 0, 0))
    draw_overlay = ImageDraw.Draw(overlay)
    draw_overlay.rectangle([0, 0, screen_w, band_height], fill=(80, 80, 80, 200))
    background_img.paste(overlay, (0, band_y), overlay)

    draw = ImageDraw.Draw(background_img)

    # POCHETTE
    image = image.resize((cover_size, cover_size), Image.LANCZOS)
    pos_x = left_margin
    pos_y = band_y - (cover_size // 2) + 20
    background_img.paste(image, (pos_x, pos_y), image)
    draw.rectangle(
        [pos_x - border_px, pos_y - border_px, pos_x + cover_size + border_px, pos_y + cover_size + border_px],
        outline=(255, 255, 255), width=2
    )

    # TEXTE position ========
    text_x = pos_x + cover_size + padding
    max_text_width = screen_w - text_x - right_margin

    y_positions = {
        "title": band_y + 20,
        "artist": band_y + 96,
        "album": band_y + 152,
        "pcm_info": band_y + 204,
        "composer": band_y + 242
    }

    def truncate_text(text, font, max_width):
        if draw.textlength(text, font=font) <= max_width:
            return text
        while draw.textlength(text, font=font) > max_width and len(text) > 0:
            text = text[:-1]
        return text[:-1] + "…"

    if title:
        draw.text((text_x, y_positions["title"]), truncate_text(title, font_title, max_text_width), font=font_title, fill=(255, 255, 255))
    if artist:
        draw.text((text_x, y_positions["artist"]), truncate_text(artist, font_artist, max_text_width), font=font_artist, fill=(255, 255, 255))
    if album:
        draw.text((text_x, y_positions["album"]), truncate_text(album, font_album, max_text_width), font=font_album, fill=(255, 255, 255))
    if pcm_info:
        draw.text((text_x, y_positions["pcm_info"]), pcm_info, font=font_pcm, fill=(255, 255, 255))
    if composer:
        draw.text((text_x, y_positions["composer"]), truncate_text("Composer: " + composer, font_composer, max_text_width), font=font_composer, fill=(255, 255, 255))

    # ======== CADRE ECRAN ========
    draw.rectangle(
        [border_px // 2, border_px // 2, screen_w - border_px // 2, screen_h - border_px // 2],
        outline=(255, 255, 255),
        width=border_px
    )

    # --- AFFICHAGE VIA FBI serv linux ---
    tmp_path = "/tmp/mpd_display.jpg"
    background_img.convert("RGB").save(tmp_path, format='JPEG', quality=95)

    # --- clé unique (morceau + fanart courant) ---
    current_key = f"{song_id}_{_fanart_index}"

    # --- seulement si image différente ---
    if not hasattr(display_image, "_last_key") or display_image._last_key != current_key:
        display_image._last_key = current_key

        # tuer anciens fbi (evite les doublons)
        os.system("pkill -9 fbi")

        # lancer fbi en arrière-plan
        os.system(f"fbi -T 1 -a -1 --noverbose {tmp_path} < /dev/tty1 > /dev/tty1 2>&1")

        print(f"[display_image] fbi affiche {tmp_path} (key={current_key})")
    else:
        print(f"[display_image] Image identique (key={current_key}), pas de relance fbi")


def safe_mpd_command(client, cmd, *args):
    try:
        return getattr(client, cmd)(*args)
    except Exception as e:
        log(f"MPD command failed ({cmd}): {e}, trying to reconnect...")
        try:
            client.disconnect()
        except Exception:
            pass
        client = connect_mpd()
        try:
            return getattr(client, cmd)(*args)
        except Exception as e2:
            log(f"MPD command still failed after reconnect: {e2}")
            return None

import time
import threading
import os

# --- Variables globales ---
_last_song_id = None
_last_fanart_change = 0
_fanart_index = 0
_last_fanart_paths = []
_last_cover = None
_last_title = ""
_last_artist = ""
_last_album = ""
_last_composer = ""
_last_pcm_info = None

FANART_CACHE_DIR = "/mnt/HDD/fanart"  # decider ou ? voir compil

# Fonctions de gestion des fanarts

def build_fanart_paths(artist):
    paths = []
    candidates = []

    # artistes en premier
    if artist:
        for n in artist.split("/"):
            n = n.strip()
            if n and n not in candidates:
                candidates.append(n)

#    # compositeur viré ensuite (dernier dans la rotation)
#    if composer:
#        for n in composer.split("/"):
#            n = n.strip()
#            if n and n not in candidates:
#                candidates.append(n)

    for n in candidates:
        key = n.replace(" ", "_").replace("/", "_").replace(";", "_")
        cache_path = os.path.join(FANART_CACHE_DIR, f"{key}.jpg")
        if not os.path.exists(cache_path):
            download_fanart_from_api(n, cache_path)
        if os.path.exists(cache_path):
            paths.append(cache_path)

    return paths


def set_new_song(fanart_paths, song_id):
    #Appeler chaque nouveau morceau pour reinitialiser le rotator.

    global _fanart_index, _last_fanart_change, _last_fanart_paths, _last_song_id
    if song_id != _last_song_id:
        _fanart_index = 0
        _last_fanart_change = time.time()
        _last_song_id = song_id
        _last_fanart_paths = fanart_paths.copy() if fanart_paths else []


def rotate_fanart(fanart_paths, last_fanart_change, fanart_index, interval=15):
    #Alterne les fanarts dans une liste en fonction intervalle tmp.
    now = time.time()
    if fanart_paths and len(fanart_paths) > 1:
        if now - last_fanart_change >= interval:
            fanart_index = (fanart_index + 1) % len(fanart_paths)
            last_fanart_change = now
    return fanart_index, last_fanart_change


def fanart_rotator(interval=15):
    # Thread qui tourne en boucle pour faire defiler les fanarts.

    global _fanart_index, _last_fanart_change
    while True:
        time.sleep(1)
        if _last_fanart_paths and _last_song_id:
            new_index, new_time = rotate_fanart(
                _last_fanart_paths,
                _last_fanart_change,
                _fanart_index,
                interval=interval
            )
            if new_index != _fanart_index:
                _fanart_index, _last_fanart_change = new_index, new_time
                print(f"[fanart_rotator] Rotation -> index {_fanart_index}")
                display_image(
                    image_data=_last_cover,
                    title=_last_title,
                    artist=_last_artist,
                    album=_last_album,
                    pcm_info=_last_pcm_info,
                    fanart_paths=_last_fanart_paths,
                    fanart_index=_fanart_index,
                    song_id=_last_song_id
                )


def download_fanart_from_api(artist_name, save_path):

    # DL le fanart depuis TheAudioDB si possible.

    try:
        response = theaudiodb_api_request(artist_name)
        if response and 'fanart_url' in response:
            url = response['fanart_url']
            # téléchargement du fichier
            with open(save_path, 'wb') as f:
                f.write(requests.get(url).content)
            print(f"[fanart] Fanart telecharge pour {artist_name}")
        else:
            print(f"[fanart] Pas de fanart trouve pour {artist_name}")
    except Exception as e:
        print(f"[fanart] Erreur telechargement {artist_name}: {e}")


def main():
    log("Script started")
    create_black_image_if_missing()
    show_logo()

    client = connect_mpd()

    # Activer les tags souhaites (moins AlbumArtist a cause api android !)
    tags = [
        "Artist", "Album", "Title", "Composer", "Performers",
        "Track", "Disc", "Genre", "Name", "Comment", "Date"
    ]
    for tag in tags:
        try:
            client.tagtypes("enable", tag)
        except Exception:
            pass

    # Variables de suivi
    last_song_id = None
    last_displayed = "logo"
    inactive_since = None
    last_cover_time = None
    fanart_index = 0
    fanart_change_interval = 20  # secondes entre changement fanart
    last_fanart_change = time.time()

    # Cache chanson
    image_data = None
    pcm_info = None
    composer = ""
    artist_name = ""
    artists = []
    fanart_paths = []

    # LANCEMENT DU THREAD FANART ROTATOR ---
    threading.Thread(target=fanart_rotator, daemon=True).start()

    try:
        while True:
            try:
                client.idle('player')
            except Exception as e:
                log(f"MPD idle failed: {e}, reconnecting...")
                try:
                    client.disconnect()
                except Exception:
                    pass
                client = connect_mpd()
                time.sleep(1)
                continue

            status = safe_mpd_command(client, "status")
            if not status:
                time.sleep(1)
                continue

            state = status.get('state')
            now = time.time()
            log(f"MPD state: {state}")

            # --- STOP ou UNKNOWN : screensaver ---
            if state in ("stop", "unknown"):
                if last_displayed == "cover" and last_cover_time and (now - last_cover_time < COVER_HOLD_TIME):
                    continue

                if inactive_since is None:
                    inactive_since = now
                elapsed = now - inactive_since

                if elapsed >= SCREENSAVER_DELAY:
                    if last_displayed != "black":
                        show_black_screen()
                        last_displayed = "black"
                continue

            # --- PLAY ou PAUSE : garder affichage ---
            elif state in ("play", "pause"):
                inactive_since = None
                song = safe_mpd_command(client, "currentsong")
                if not song:
                    continue

                song_id = song.get('id')

                # Nouvelle chanson detecte
                if song_id != last_song_id:
                    last_song_id = song_id
                    log(f"Now playing: {song.get('title', '')} by {song.get('artist', '')}")

                    filepath = song.get('file', '')
                    image_data = None

                    if filepath.startswith("http"):
                        image_data = try_fetch_mconnect_qobuz_stream_cover(filepath)
                        if not image_data:
                            image_data = download_stream_cover(song)
                    else:
                        full_path = os.path.join("/media", filepath) if not filepath.startswith("/") else filepath
                        folder = os.path.dirname(full_path)
                        cover_path = find_local_cover(folder)
                        if cover_path:
                            try:
                                image_data = open(cover_path, 'rb')
                            except Exception as e:
                                log(f"Error opening cover image file: {e}")
                                image_data = None
                        else:
                            image_data = extract_embedded_cover(full_path)

                    if not image_data:
                        log("No cover found, skipping display")
                        continue

                    pcm_info = get_audio_format(client)

                    composer = song.get('composer', '')
                    if not composer:
                        composer = extract_composer_from_performers(song)

                    artist_name = song.get('artist', '')
                    artists = split_artists_smart(artist_name)

                    # --- Recuperation fanart avec composer et albumartist ---
                    fanart_paths = get_artist_fanart(
                        artist_name=artists,
                    )

                    if not fanart_paths:
                        log("No fanart found for any artist")
                        nofanart_file = "/opt/mount-api/nofanart.js"
                        for artist in artists:
                            try:
                                if os.path.exists(nofanart_file):
                                    with open(nofanart_file, "r", encoding="utf-8") as f:
                                        existing_artists = f.read().splitlines()
                                else:
                                    existing_artists = []

                                if artist not in existing_artists:
                                    with open(nofanart_file, "a", encoding="utf-8") as f:
                                        f.write(artist + "\n")
                                    log(f"Artist '{artist}' added to nofanart.js")
                            except Exception as e:
                                log(f"Erreur ecriture dans nofanart.js : {e}")

                    fanart_index = 0
                    last_fanart_change = now

                    # --- Mise UP variables globales pour le thread ---
                    global _last_fanart_paths, _last_song_id, _last_cover
                    global _last_title, _last_artist, _last_album, _last_composer, _last_pcm_info
                    global _fanart_index, _last_fanart_change

                    _last_fanart_paths = fanart_paths
                    _last_song_id = song_id
                    _last_cover = image_data
                    _last_title = song.get('title', '')
                    _last_artist = artist_name
                    _last_album = song.get('album', '')
                    _last_composer = composer
                    _last_pcm_info = pcm_info
                    _fanart_index = fanart_index
                    _last_fanart_change = last_fanart_change

                # --- Rotation fanart ---
                fanart_index, last_fanart_change = rotate_fanart(
                    fanart_paths, last_fanart_change, fanart_index, fanart_change_interval
                )

                display_image(
                    image_data,
                    title=song.get('title', ''),
                    artist=artist_name,
                    album=song.get('album', ''),
                    composer=composer,
                    pcm_info=pcm_info,
                    fanart_paths=fanart_paths,
                    fanart_index=fanart_index,
                    song_id=song.get("file", "")
                )
                last_displayed = "cover"
                last_cover_time = now

    except KeyboardInterrupt:
        log("Interrupted")
    finally:
        try:
            client.close()
            client.disconnect()
        except Exception:
            pass


# --- Entry point ---
if __name__ == "__main__":
    main()